# MySQL单库分表

场景：单表每月新增1.5亿条日志。磁盘占满、查询超时。

表的索引字段：log_id, doc_id和created_at。业务的查询，只会使用者三个索引。其中log_id是主键。

## 分表方案

使用雪花算法生成log_id，然后根据log_id的前42位时间戳和表做映射，用此ID作为partition key。每个季度创建一个表。此时需要解决使用doc_id这个辅助索引查询的场景。

我们的场景是日志每月新增1.5亿，文档id每月只有1200万。查询是有倾斜的，大部分的查询都是最近生成的doc_id。也就是说大部分查询是在最近的表中进行的。

目前主流的辅助索引有两种分区方式：

* **本地辅助索引（Locl Secondary Index）** 每个分区维护该分片数据的辅助索引，当查询辅助索引的时候，所有分片同时查询。
* **全局辅助索引（Global Secondary Index）** 只在一个分区维护全局数据的辅助索引，当查询辅助索引的时候，只需要查询一个分片。

本地辅助索引会导致同时查询所有的分表。在当前分表策略下，表的数量是线性增加的，如果同时查询所有的表，数据库负载过高。因为doc_id的生成也是和时间相关的，即使不像雪花算法一样可以精确的从id计算出时间戳，但是也可以大致确定生成的时间。同时业务隐含了这样的约束：doc_id对应的日志不会再之前的表中存在。这样对于指定的doc_id，可以确定它存在的表的范围：[doc_id生成时间, 当前时间)。

此时采用全局辅助索引的策略，将所有的doc_id保存在映射表中。但是这个映射表不会为每个doc_id记录它可能存在表。我们计算每个季度中第一个生成的id，然后只保存这个id对应的表：

````
key 开始出现的表
key1 202001
key2 202002
key3 202003
````

对于给定的doc_id，一定在一下的某个区间内：[key1, key2), [key2, key3), [key3, ∞]。然后就可以知道需要查询的表了。如果一个doc_id在[key1, key2)中，只需要查询202001，202002，202003这三个表。但是大部分的doc_id查询会在[key3, ∞)这个区间，所以只需要查询202003这个表。



## Q&A

为什么不分库？当前业务虽然数据量大，但是读写的请求并不多，只需要解决单表数据过大的问题。

为什么不适用中间件，比如MyCat等？当前业务的写入和查询逻辑简单，没有必要以来第三中间件，增加额外的成本。

