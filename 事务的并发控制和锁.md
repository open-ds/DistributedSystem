# 事务的并发控制和锁

这篇文章的目的的加深对InnoDB的MVCC、Next-Key和事务的隔离级别的理解。

## 并发带来的问题

事务的并发执行会根据事务之间的数据依赖关系带来三个问题：

* **脏读** 一个事务读取到了另一个事务未提交的数据
* **不可重复读** 一个事务中读取的存在的数据可能被另一个事务修改或者删除
* **幻读** 一个事务中读取的结果集可能会被另一个事务修改，结果集中的数据可能变多也可能表少


## 事务的隔离级别

根据并发执行可能带来的问题，上面的问题分别叫做P1、P2和P3，SQL-92定义了三个事务隔离级别。

| Isolation Level  | P1 | P2  | P3  |
|------------------|-----|-----|-----|
| Read Uncommitted | YES | YES | YES |
| Read Committed   | NO  | YES | YES |
| Repeatable Read  | NO  | NO  | YES |
| Serializable     | NO  | NO  | NO  |

## 使用锁解决不可重复读和幻读

不可重复读的问题是在事务读取数据的时候，没有对记录加锁，导致其它事务可以修改当前事务读取的数据。所以可以对查询匹配的数据加锁。这种锁叫做记录锁。但是不存在的记录却无法加锁。

虽然对用户来说，数据的粒度只有表和记录，但是对于使用B+树的存储引擎来说，B+树的结点也是可以加锁的对象。在InnoDB的实现中，一个B+树节点对应一个数据页，可以对页进行加锁。对一个页加锁，就是对一个或者多个区间加锁。

比如图1中一个B+树。

![b-plus-tree](https://www.vertabelo.com/blog/all-about-indexes-part-2-mysql-index-structure-and-performance/b-plus-tree.png)

当执行`SELECT ... WHERE id BETWEEN 4 TO 10 FOR UPDATE`的时候，InnoDB会对(3, 5], (5, 11]这个区间进行加锁。更具体点就是对这两个区间所在页的偏移量加锁。这种加锁方式就做next-key locking。此时其它事务无法在这两个区间修改、新增和删除数据。

## 锁和操作记录

不管是reord locking还是next-key locking都是从加锁对象的粒度来区分的，它们都可以叫做粒度锁。但是对多个对象进行加锁和释放锁必须需要定义顺序，需要根据加锁的顺序生成对应的操作记录。

操作记录，或者说InnoDB中undo log的作用是保证事务ACID属性的关键。一般使用Two-Phase Locking来规定加锁和释放锁的顺序，这样才能生成正确的操作历史。只所以说是两个阶段，是因为在一个阶段，事务的锁的数目一直在增加，在另一个阶段，事务的锁的数目一直在减少。在执行SQL语句的过程中，锁越来越堵，在COMMIT或者ROLLBACK之前，所被依次释放。

## MVCC

并发执行事务就是为了提高性能，而锁会损害性能。解决不可重复读和幻读必须要对多个区间加锁，但是InnoDB实现了快照读来避免对读进行加锁。这Read Commited和Repeatable Read隔离级别下，InnoDB实施快照读。快照的生成策略却不同。

* Read Committed 在事务中，每次读都会重新生成一个快照
* Repeatable Read 在事务中，只有第一次读会生成快照，以后的读都是读取这个快照

当事务没有提交的时候，会在undo log保存当前事务处理的数据。同时在表空间的记录也会保留一个事务id。当创建一个快照的时候，会计算up_trx_id和low_trx_id，以及这个范围中的事务id列表。Repeatable Read只能读取事务id小于up_trx_id的记录。Read Committed不仅可以读取事务id小于up_trx_id，还可以读取在[up_trx_id, low_trx_id]范围的，但是不在列表中的数据。不在列表中数据表示对应的事务已经提交了。

对于不同的事务，会看到不同版本的数据，这就叫做MVCC(Multi-Version Concurrency Control)，旨在提高并发性能。具体可见[MySQL InnoDB MVCC实现](https://zhuanlan.zhihu.com/p/40208895)。

但是MVCC会找出更新丢失问题，如果一个事务根据快照读的结果来决定是否修改快照内的数据，可能当前事物读取的是过时的数据，如果此时修改，将会覆盖掉其它事务的修改。在这种情况下，对SELECT需要加上`FOR UPDATE`或者`LOCK IN SHARE MODE`。



